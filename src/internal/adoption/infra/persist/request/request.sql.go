// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: request.sql

package querier

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const approveRequest = `-- name: ApproveRequest :exec
UPDATE adoption.request
SET approved_at = NOW()
WHERE id = $1
`

func (q *Queries) ApproveRequest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, approveRequest, id)
	return err
}

const createRequest = `-- name: CreateRequest :exec
INSERT INTO adoption.request (
    id,
    pet_id,
    name,
    email,
    phone,
    age,
    house_hold_agreed,
    alreadyPets,
    already_pets_castrated_and_vaccinated,
    property,
    own_property,
    address,
    income,
    suitable_location,
    access_to_the_street
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14, $15
)
`

type CreateRequestParams struct {
	ID                                uuid.UUID
	PetID                             uuid.UUID
	Name                              string
	Email                             string
	Phone                             string
	Age                               int32
	HouseHoldAgreed                   bool
	Alreadypets                       int32
	AlreadyPetsCastratedAndVaccinated bool
	Property                          PropertyType
	OwnProperty                       bool
	Address                           string
	Income                            int32
	SuitableLocation                  string
	AccessToTheStreet                 pgtype.Bool
}

func (q *Queries) CreateRequest(ctx context.Context, arg CreateRequestParams) error {
	_, err := q.db.Exec(ctx, createRequest,
		arg.ID,
		arg.PetID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Age,
		arg.HouseHoldAgreed,
		arg.Alreadypets,
		arg.AlreadyPetsCastratedAndVaccinated,
		arg.Property,
		arg.OwnProperty,
		arg.Address,
		arg.Income,
		arg.SuitableLocation,
		arg.AccessToTheStreet,
	)
	return err
}

const getRequestById = `-- name: GetRequestById :one
SELECT
    id,
    pet_id,
    name,
    email,
    phone,
    approved_at,
    age,
    house_hold_agreed,
    alreadyPets,
    already_pets_castrated_and_vaccinated,
    property,
    own_property,
    address,
    income,
    suitable_location,
    access_to_the_street,
    created_at
FROM adoption.request
WHERE id = $1
`

func (q *Queries) GetRequestById(ctx context.Context, id uuid.UUID) (AdoptionRequest, error) {
	row := q.db.QueryRow(ctx, getRequestById, id)
	var i AdoptionRequest
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.ApprovedAt,
		&i.Age,
		&i.HouseHoldAgreed,
		&i.Alreadypets,
		&i.AlreadyPetsCastratedAndVaccinated,
		&i.Property,
		&i.OwnProperty,
		&i.Address,
		&i.Income,
		&i.SuitableLocation,
		&i.AccessToTheStreet,
		&i.CreatedAt,
	)
	return i, err
}

const listRequests = `-- name: ListRequests :many
SELECT
    id,
    pet_id,
    name,
    email,
    phone,
    approved_at,
    age,
    house_hold_agreed,
    alreadyPets,
    already_pets_castrated_and_vaccinated,
    property,
    own_property,
    address,
    income,
    suitable_location,
    access_to_the_street,
    created_at
FROM adoption.request
ORDER BY created_at DESC
`

func (q *Queries) ListRequests(ctx context.Context) ([]AdoptionRequest, error) {
	rows, err := q.db.Query(ctx, listRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdoptionRequest
	for rows.Next() {
		var i AdoptionRequest
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.ApprovedAt,
			&i.Age,
			&i.HouseHoldAgreed,
			&i.Alreadypets,
			&i.AlreadyPetsCastratedAndVaccinated,
			&i.Property,
			&i.OwnProperty,
			&i.Address,
			&i.Income,
			&i.SuitableLocation,
			&i.AccessToTheStreet,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
