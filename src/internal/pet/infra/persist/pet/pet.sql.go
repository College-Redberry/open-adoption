// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pet.sql

package querier

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const adoptPetById = `-- name: AdoptPetById :exec
UPDATE pets.pets
SET is_adopted = TRUE
WHERE id = $1
`

func (q *Queries) AdoptPetById(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, adoptPetById, id)
	return err
}

const countPets = `-- name: CountPets :one
SELECT COUNT(1)
FROM pets.pets
WHERE ($1::text IS NULL OR name ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR breed ILIKE '%' || $2 || '%')
  AND ($3::text IS NULL OR age = $3)
  AND ($4::text IS NULL OR gender = $4::pet_gender)
  AND ($5::boolean IS NULL OR is_adopted = $5)
`

type CountPetsParams struct {
	Name      pgtype.Text
	Breed     pgtype.Text
	Age       pgtype.Text
	Gender    pgtype.Text
	IsAdopted pgtype.Bool
}

func (q *Queries) CountPets(ctx context.Context, arg CountPetsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPets,
		arg.Name,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.IsAdopted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPet = `-- name: CreatePet :exec
INSERT INTO pets.pets (
    id, name, description, breed, age, gender, is_adopted
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreatePetParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	Breed       string
	Age         string
	Gender      PetGender
	IsAdopted   bool
}

func (q *Queries) CreatePet(ctx context.Context, arg CreatePetParams) error {
	_, err := q.db.Exec(ctx, createPet,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.IsAdopted,
	)
	return err
}

const getPetById = `-- name: GetPetById :one
SELECT id, name, description, breed, age, gender, is_adopted
FROM pets.pets
WHERE id = $1
`

type GetPetByIdRow struct {
	ID          uuid.UUID
	Name        string
	Description string
	Breed       string
	Age         string
	Gender      PetGender
	IsAdopted   bool
}

func (q *Queries) GetPetById(ctx context.Context, id uuid.UUID) (GetPetByIdRow, error) {
	row := q.db.QueryRow(ctx, getPetById, id)
	var i GetPetByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.IsAdopted,
	)
	return i, err
}

const insertPetImages = `-- name: InsertPetImages :exec
INSERT INTO pets.pet_images (id, pet_id, url)
SELECT gen_random_uuid(), $1, url
FROM unnest($2::text[]) AS url
`

type InsertPetImagesParams struct {
	PetID   pgtype.UUID
	Column2 []string
}

func (q *Queries) InsertPetImages(ctx context.Context, arg InsertPetImagesParams) error {
	_, err := q.db.Exec(ctx, insertPetImages, arg.PetID, arg.Column2)
	return err
}

const listImagesById = `-- name: ListImagesById :many
SELECT url
FROM pets.pet_images
WHERE pet_id = $1
`

func (q *Queries) ListImagesById(ctx context.Context, petID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listImagesById, petID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var url string
		if err := rows.Scan(&url); err != nil {
			return nil, err
		}
		items = append(items, url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPets = `-- name: ListPets :many
SELECT id, name, description, breed, age, gender, is_adopted
FROM pets.pets
WHERE ($3::text IS NULL OR name ILIKE '%' || $3 || '%')
  AND ($4::text IS NULL OR breed ILIKE '%' || $4 || '%')
  AND ($5::text IS NULL OR age = $5)
  AND ($6::text IS NULL OR gender = $6::pet_gender)
  AND ($7::boolean IS NULL OR is_adopted = $7)
ORDER BY name
LIMIT $1
OFFSET $2
`

type ListPetsParams struct {
	Limit     int32
	Offset    int32
	Name      pgtype.Text
	Breed     pgtype.Text
	Age       pgtype.Text
	Gender    pgtype.Text
	IsAdopted pgtype.Bool
}

type ListPetsRow struct {
	ID          uuid.UUID
	Name        string
	Description string
	Breed       string
	Age         string
	Gender      PetGender
	IsAdopted   bool
}

func (q *Queries) ListPets(ctx context.Context, arg ListPetsParams) ([]ListPetsRow, error) {
	rows, err := q.db.Query(ctx, listPets,
		arg.Limit,
		arg.Offset,
		arg.Name,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.IsAdopted,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPetsRow
	for rows.Next() {
		var i ListPetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Breed,
			&i.Age,
			&i.Gender,
			&i.IsAdopted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePet = `-- name: UpdatePet :exec
UPDATE pets.pets
SET name = $2,
    description = $3,
    breed = $4,
    age = $5,
    gender = $6
WHERE id = $1
`

type UpdatePetParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	Breed       string
	Age         string
	Gender      PetGender
}

func (q *Queries) UpdatePet(ctx context.Context, arg UpdatePetParams) error {
	_, err := q.db.Exec(ctx, updatePet,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Breed,
		arg.Age,
		arg.Gender,
	)
	return err
}
